% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coque.R
\name{coque}
\alias{coque}
\title{Penalized composite quadratic estimator (COQUE) for multivariate longitudinal/independent cluster GLMMs.}
\usage{
coque(
  object,
  nlambda = 100,
  lambda_min_ratio = 1e-06,
  lambda = NULL,
  min_df = 0,
  num_cores = NULL,
  control = list(maxit = 1000, eps = 1e-06, round_eps = 1e-06, fallback_to_bread = TRUE)
)
}
\arguments{
\item{object}{An object of class \code{stackedGLMM}.}

\item{nlambda}{The number of tuning parameters values.}

\item{lambda_min_ratio}{The smallest value for the tuning parameter lambda, as a fraction of the maximum internally-derived lambda value i.e., a value such that penalization leads to zeros for all penalized estimates.}

\item{lambda}{A user-supplied tuning parameter sequence. Note this is usually not supplied, as it is standard to have the function itself compute its own lambda sequence based on \code{nlambda} and \code{lambda_min_ratio}.}

\item{min_df}{The minimum number of non-zero fixed-effect coefficients, excluding the intercept, allowed in the model. This is useful to supply if, when the function tries to find a appropriate lambda sequence, the user wants the maximum value of lambda to not necessarily shrink to all the penalized estimates to zero. Defaults to zero, and can take a maximum value given by \code{length(selection_indices)}.}

\item{num_cores}{The regularization path is constructed via parallel computing, and this argument controls the number of cores used. Defaults to \code{NULL}, in which case it is set to \code{parallel::detectCores() - 2}.}

\item{control}{A list containing the following elements:
\itemize{
\item{maxit: }{the maximum number of iterations in the algorithm.}
\item{eps: }{the convergence criterion; the norm of the difference between estimates from successive iterations must be smaller than this value.}
\item{round_eps: }{a tolerance to round values to zero; this is technically not needed as COQUE and the broken adaptive ridge penalty will produce exactly zero estimates up to machine error, but is included anyway.}
\item{fallback_to_bread: }{whether to use replace the sandwich information matrix with the observed information (i.e., the bread) matrix if instabilities are detected in the former.}
}}
}
\value{
An object of class \code{coque} with the following elements (and not necessarily in the order below):
\item{call:}{The function call.}
\item{lambda:}{The actual sequence of tuning parameter, lambda, values used.}
\item{psi_path:}{A sparse matrix showing the estimated parameters at each point on the regularization path. The number of rows is equal \code{length(psihat)}, while the number of columns is equal to \code{length(lambda)}. The parameters are ordered so that all the fixed effect coefficients appear first (running as covariates within response), followed by any nuisance parameters and random effects variance parameters.}
\item{coque_statistics_path:}{A vector showing the value of the composite quadratic approximation statistic at each point on the regularization path.}
\item{df_path:}{A vector showing the number of non-zero estimated values in the (reparametrized) \code{psihat} at each point on the regularization path. This is used for calculating information criterion. Note \code{df_path} counts all parameters, not just those up for selection. This is consistent with the fact that the composite quadratic estimator is constructed with respect to all the parameters in the composite likelihood. }
\item{ICs:}{A matrix of some information criteria and their values on the regularization path. The number of rows is equal to \code{length(lambda)}. The current information criteria calculated include:
Akaike information criterion (AIC) with model complexity penalty of 2;
Bayesian information criterion (BIC) with model complexity penalty of \code{log(num_clus)} where \code{num_clus} is the numbers of clusters in the multivariate GLMM;
Extended Bayesian information criterion (EBIC) with model complexity penalty of \code{log(num_clus) + log(penalized parameters)};
Extended Bayesian information criterion (EBIC2) with model complexity penalty of \code{log(num_clus) + 2 * log(penalized parameters)}.}
\item{time_taken:}{The time taken to construct the regularization path.}
\item{num_resp/num_clus...:}{Additional auxilary function that can be safely ignored.}
\item{additional_information:}{This can be safely ignored.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

The COQUE objective function being optimized is \code{-0.5 * t(psi - psihat) \%^\% G \%*\% (psi - psihat) - lambda * penalty}, where \code{psihat} are the composite likelihood estimates produced from the stacked univariate GLMM (see the \code{\link[=stackedGLMMs]{stackedGLMMs()}} function), \code{G} is the sandwich or Godambe information matrix, and \code{penalty} is a set of broken adaptive ridge (fusion) penalties to achieve simultaneous variable selection and coefficient clustering on the fixed effect coefficients. Construction of the regularization path for COQUE is done via parallel computing.

\strong{No penalization of the random effects is performed.}
}
\details{
See associated manuscript (currently in revision).
}
\examples{
\dontrun{
##------------------
# Example 1: Simulated binary responses
# Inspired by [http://dx.doi.org/10.1016/j.csda.2017.09.004]
##------------------
## Basic set up and true parameters
set.seed(052024)
library(mvtnorm)
num_clus <- 200
num_resp <- 6
response_type <- "binomial"
dat <- data.frame(id = rep(1:num_clus, sample(10:15, size = num_clus, replace = TRUE)))
p <- 15
H <- abs(outer(1:p, 1:p, "-"))
X <- rmvnorm(nrow(dat), sigma = 0.5^H)
colnames(X) <- paste0("x", 1:ncol(X))
dat <- cbind(dat, X)
rm(X)
str(dat)
true_fixed_effects <- cbind(
runif(num_resp, -1, 1),
rnorm(num_resp,0.5,sd=0.5),
rnorm(num_resp,-0.5,sd=0.5),
replicate(4, sample(c(-0.25,0,0.25),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 3 unique values, including zero
replicate(4, sample(c(-0.125,0),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 2 unique values, including zero
replicate(5, numeric(num_resp)))
true_fixed_effects

true_G <- rbind(c(1,0.8,0.4,-0.6,-0.3,-0.15),
c(0.8,1,0.6,-0.4,-0.2,-0.1),
c(0.4,0.6,1,-0.2,-0.1,-0.05),
c(-0.6,-0.4,-0.2,1,0.6,0.3),
c(-0.3,-0.2,-0.1,0.6,1,0.3),
c(-0.15,-0.1,-0.05,0.3,0.3,1))

true_ranef_cov <- rbind(c(2,1,0,0,0),
c(1,2,0,0,0),
c(0,0,1,0,0),
c(0,0,0,0.5,0),
c(0,0,0,0,0.25))/2

true_Sigma <- kronecker(true_G, true_ranef_cov)

rm(H, p)

## Simulate longitudinal/independent cluster multivariate responses
simy <- generatedata_mglmm(formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat,
fixed_effects = true_fixed_effects,
Sigma = true_Sigma,
response_type = response_type,
trial_size = 1)

str(simy)


## Apply COQUE -- **Real application starts here**

# 1. Fitting stacked univariate GLMMs
sglmms <- stackedGLMMs(y = simy$y[,-ncol(simy$y)],
response_type = response_type,
formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat,
trial_size = 1)

str(sglmms)

# 2. Pass to the COQUE fit
penalized_fit <- coque(object = sglmms)
penalized_fit$lambda
penalized_fit$df
penalized_fit$ICs

parameter_estimates <- estimates(penalized_fit, lambda = "BIC", hybrid = TRUE)

parameter_estimates$hybrid # Compare with true_fixed_effects
parameter_estimates$random_effects_covariance


##------------------
# Example 2: Simulated Poisson responses
# Inspired by [http://dx.doi.org/10.1016/j.csda.2017.09.004]
##------------------
## Basic set up and true parameters
set.seed(052024)
library(mvtnorm)
num_clus <- 100
num_resp <- 6
response_type <- "poisson"
dat <- data.frame(id = rep(1:num_clus, sample(10:15, size = num_clus, replace = TRUE)))

p <- 15
H <- abs(outer(1:p, 1:p, "-"))
X <- rmvnorm(nrow(dat), sigma = 0.5^H)
colnames(X) <- paste0("x", 1:ncol(X))
dat <- cbind(dat, X)
rm(X)
str(dat)

true_fixed_effects <- cbind(
runif(num_resp, -1, 1),
rnorm(num_resp,0.5,sd=0.5),
rnorm(num_resp,-0.5,sd=0.5),
replicate(4, sample(c(-0.25,0,0.25),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 3 unique values, including zero
replicate(4, sample(c(-0.125,0),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 2 unique values, including zero
replicate(5, numeric(num_resp)))
true_fixed_effects

true_G <- rbind(c(1,0.8,0.4,-0.6,-0.3,-0.15),
c(0.8,1,0.6,-0.4,-0.2,-0.1),
c(0.4,0.6,1,-0.2,-0.1,-0.05),
c(-0.6,-0.4,-0.2,1,0.6,0.3),
c(-0.3,-0.2,-0.1,0.6,1,0.3),
c(-0.15,-0.1,-0.05,0.3,0.3,1))

true_ranef_cov <- rbind(c(2,1,0,0,0),
c(1,2,0,0,0),
c(0,0,1,0,0),
c(0,0,0,0.5,0),
c(0,0,0,0,0.25))/2
true_Sigma <- kronecker(true_G, true_ranef_cov)

rm(H, p)

## Simulate longitudinal/independent cluster multivariate responses
simy <- generatedata_mglmm(formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat,
fixed_effects = true_fixed_effects,
Sigma = true_Sigma,
response_type = response_type)

str(simy)


## Apply COQUE -- **Real application starts here**

# 1. Fitting stacked univariate GLMMs
sglmms <- stackedGLMMs(y = simy$y[,-ncol(simy$y)],
response_type = response_type,
formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat)

str(sglmms)

# 2. Pass to the COQUE fit
penalized_fit <- coque(object = sglmms)
penalized_fit$lambda
penalized_fit$df
penalized_fit$ICs

parameter_estimates <- estimates(penalized_fit, lambda = "EBIC", hybrid = TRUE)

parameter_estimates$hybrid # Compare with true_fixed_effects
parameter_estimates$random_effects_covariance


##------------------
# Example 3: Simulated Tweedie responses
# Inspired by [http://dx.doi.org/10.1016/j.csda.2017.09.004]
##------------------
## Basic set up and true parameters
set.seed(052024)
library(mvtnorm)
num_clus <- 200
num_resp <- 6
response_type <- "tweedie"
dat <- data.frame(id = rep(1:num_clus, sample(10:15, size = num_clus, replace = TRUE)))

p <- 15
H <- abs(outer(1:p, 1:p, "-"))
X <- rmvnorm(nrow(dat), sigma = 0.5^H)
colnames(X) <- paste0("x", 1:ncol(X))
dat <- cbind(dat, X)
rm(X)
str(dat)

true_fixed_effects <- cbind(
runif(num_resp, -1, 1),
rnorm(num_resp,0.5,sd=0.5),
rnorm(num_resp,-0.5,sd=0.5),
replicate(4, sample(c(-0.25,0,0.25),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 3 unique values, including zero
replicate(4, sample(c(-0.125,0),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 2 unique values, including zero
replicate(5, numeric(num_resp)))
true_fixed_effects

true_G <- rbind(c(1,0.8,0.4,-0.6,-0.3,-0.15),
c(0.8,1,0.6,-0.4,-0.2,-0.1),
c(0.4,0.6,1,-0.2,-0.1,-0.05),
c(-0.6,-0.4,-0.2,1,0.6,0.3),
c(-0.3,-0.2,-0.1,0.6,1,0.3),
c(-0.15,-0.1,-0.05,0.3,0.3,1))

true_ranef_cov <- rbind(c(2,1,0,0,0),
c(1,2,0,0,0),
c(0,0,1,0,0),
c(0,0,0,0.5,0),
c(0,0,0,0,0.25))/2
true_Sigma <- kronecker(true_G, true_ranef_cov)
true_phi <- runif(num_resp,0,2)
true_power <- runif(num_resp, 1.2, 1.8)

rm(H, p)

## Simulate longitudinal/independent cluster multivariate responses
simy <- generatedata_mglmm(formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat,
fixed_effects = true_fixed_effects,
Sigma = true_Sigma,
response_type = response_type,
phi = true_phi,
power = true_power)

str(simy)


## Apply COQUE -- **Real application starts here**

# 1. Fitting stacked univariate GLMMs
sglmms <- stackedGLMMs(y = simy$y[,-ncol(simy$y)],
response_type = response_type,
formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat)

str(sglmms)

# 2. Pass to the COQUE fit
penalized_fit <- coque(object = sglmms)
penalized_fit$lambda
penalized_fit$df
penalized_fit$ICs

parameter_estimates <- estimates(penalized_fit, lambda = "BIC", hybrid = TRUE)

parameter_estimates$hybrid # Compare with true_fixed_effects
parameter_estimates$random_effects_covariance


##------------------
# Example 4: Simulated ordinal responses
# Inspired by [http://dx.doi.org/10.1016/j.csda.2017.09.004]
##------------------
## Basic set up and true parameters
set.seed(052024)
library(mvtnorm)
num_clus <- 200
num_resp <- 6
response_type <- "ordinal"
dat <- data.frame(id = rep(1:num_clus, sample(10:15, size = num_clus, replace = TRUE)))

p <- 15
H <- abs(outer(1:p, 1:p, "-"))
X <- rmvnorm(nrow(dat), sigma = 0.5^H)
colnames(X) <- paste0("x", 1:ncol(X))
dat <- cbind(dat, X)
rm(X)
str(dat)

true_fixed_effects <- cbind(
runif(num_resp, -1, 1),
rnorm(num_resp,0.5,sd=0.5),
rnorm(num_resp,-0.5,sd=0.5),
replicate(4, sample(c(-0.25,0,0.25),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 3 unique values, including zero
replicate(4, sample(c(-0.125,0),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 2 unique values, including zero
replicate(5, numeric(num_resp)))
true_fixed_effects

true_G <- rbind(c(1,0.8,0.4,-0.6,-0.3,-0.15),
c(0.8,1,0.6,-0.4,-0.2,-0.1),
c(0.4,0.6,1,-0.2,-0.1,-0.05),
c(-0.6,-0.4,-0.2,1,0.6,0.3),
c(-0.3,-0.2,-0.1,0.6,1,0.3),
c(-0.15,-0.1,-0.05,0.3,0.3,1))

true_ranef_cov <- rbind(c(2,1,0,0,0),
c(1,2,0,0,0),
c(0,0,1,0,0),
c(0,0,0,0.5,0),
c(0,0,0,0,0.25))/2
true_Sigma <- kronecker(true_G, true_ranef_cov)
true_cutoffs <- cbind(0, matrix(c(1,2,3), nrow = num_resp, ncol = 3, byrow = TRUE))

rm(H, p)

## Simulate longitudinal/independent cluster multivariate responses
simy <- generatedata_mglmm(formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat,
fixed_effects = true_fixed_effects,
Sigma = true_Sigma,
response_type = response_type,
cutoffs = true_cutoffs)

str(simy)


## Apply COQUE -- **Real application starts here**

# 1. Fitting stacked univariate GLMMs
sglmms <- stackedGLMMs(y = simy$y[,-ncol(simy$y)],
response_type = response_type,
formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat)

str(sglmms)

# 2. Pass to the COQUE fit
penalized_fit <- coque(object = sglmms)
penalized_fit$lambda
penalized_fit$df
penalized_fit$ICs

parameter_estimates <- estimates(penalized_fit, lambda = "BIC", hybrid = TRUE)

parameter_estimates$hybrid # Compare with true_fixed_effects
parameter_estimates$random_effects_covariance
}


}
\seealso{
\code{\link[=estimates.coque]{estimates.coque()}} for extracting values from a COQUE fit, \code{\link[=stackedGLMMs]{stackedGLMMs()}} for fitting stacked univariate generalized linear mixed models (not this function has to be run upstream of running the main \code{coque} function), and \code{\link[=generatedata_mglmm]{generatedata_mglmm()}} for simulating data from a longitudinal/independent cluster multivariate generalized linear mixed model.
}
\author{
Francis K.C. Hui \href{mailto:fhui28@gmail.com}{fhui28@gmail.com}
}
