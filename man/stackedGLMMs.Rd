% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stackedGLMMs.R
\name{stackedGLMMs}
\alias{stackedGLMMs}
\title{Fit stacked univariate generalized linear mixed models (GLMMs).}
\usage{
stackedGLMMs(
  y,
  response_type,
  formula_X,
  formula_Z,
  data,
  trial_size = 1,
  start_params = NULL,
  TMB_directories = list(cpp = system.file("executables", package = "COQUE"), compile =
    system.file("executables", package = "COQUE")),
  num_cores = NULL,
  score_vectors = TRUE,
  control = list(iter.max = 1000, eval.max = 1000, trace = 0, attempts = 20)
)
}
\arguments{
\item{y}{A matrix of multivariate longitudinal responses, where the number of columns equal to the number of responses.}

\item{response_type}{The distribution of the responses for the model. Currently, it is assumed all responses follow the same distribution, which can be one of "gaussian", "poisson", "binomial", "ordinal", "tweedie".}

\item{formula_X}{One-sided formula for the fixed effects component of the model. All responses are assumed to be effected by the same formula; sparsity and clustering is instead controlled by the \code{fixed_effects} argument.}

\item{formula_Z}{One-sided formula for the random effects component of the model. All responses are assumed to be effected by the same formula; sparsity and clustering is instead controlled by the \code{Sigma} argument.}

\item{data}{A data frame from which containing relevant fixed and random effect covariate information, and, importantly, \strong{must} also contain a column called "id" which indexes the cluster of each row in the data frame.}

\item{trial_size}{A vector of response-specific trial sizes, which is needed for binomial distributed responses.}

\item{start_params}{Starting values can be supplied. This must take the form of a list with length equal to the number of responses i.e., the number of columns in \code{y}. Each element in the list should then contain:
\itemize{
\item{fixed_effects}{a vector of starting values for the fixed effect coefficients.}
\item{random_effects}{a matrix of starting values for the random effect coefficients where the number of columns is equal to the number of columns of the model matrix implied by \code{formula_Z}.}
\item{sd}{a vector of standard deviation parameters for the random effects covariance matrix.}
\item{unconstrained_cor_params}{a vector of parameters corresponding to the lower-triangular elements of the Cholesky decomposition of the random effects correlation matrix. We refer the reader to \url{https://kaskr.github.io/adcomp/_book/Densities.html} to see how covariance matrices are parametrized in \code{TMB}.}
}}

\item{TMB_directories}{A list with two elements, identifying the directory where TMB C++ file exists (\code{cpp}), and the directory where the corresponding compiled files to be placed (\code{compile}). \emph{Unless you really want to do some real mucking around, these should be left at their default i.e., the directory where the packages were installed locally. Please note a version of the C++ file will be copied to the \code{compile} directory.}}

\item{num_cores}{The number of cores to use for parallelization of the stacked GLMM fitting. Defaults to the \code{parallel::detectCores()-2}.}

\item{score_vectors}{Should vectors of the score values for each cluster within each responses be returned. Defaults to \code{TRUE} and this generally should \emph{not} be turned off.}

\item{control}{A list controlling the some of the tuning parameters in the optimization process for fitting the stacked GLMMs, noting \code{\link[stats:nlminb]{stats::nlminb()}} is used to perform the optimization. These include:
\itemize{
\item{iter.max}{the maximum number of iterations allowed.}
\item{eval.max}{the maximum number of evaluations of the objective function allowed.}
\item{trace}{this can be set to a positive value so that the value of the objective function and the parameters is printed every \code{trace}'th iteration.}
\item{attempts}{the number of attempts are made to fit each stacked univariate GLMM (if \code{\link[stats:nlminb]{stats::nlminb()}} fails on the first try).}
}}
}
\value{
A object for class "stackedGLMM" which contains the following:
\item{respxxx:}{The first \code{ncol(y)} elements contains the estimated stacked GLMMs corresponding to each response. Each element is itself a list containing: the fitted model output from TMB (\code{fit} and \code{sdreport}), a list of estimated parameters and random effects in a slightly tidier format (\code{point_estimates}), and a matrix of score vector values for each cluster (\code{score_vectors}).}
\item{call:}{The function call.}
\item{formula_X/formula_Z/data/response_type/num_resp:}{Arugment information that can be safely ignored.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

This function can be used on its own, but in the context of this the package, it is primarily utilized upstream of applying \code{\link[=coque]{coque()}} for simultaneous selection and clustering of the fixed effects. Fitting of the GLMMs is done via \code{\link[TMB:MakeADFun]{TMB::MakeADFun()}}, which optimizes the Laplace-approximated marginal log-likelihood function using automatic differentiation.
}
\details{
See associated manuscript (currently in revision).
}
\examples{
\dontrun{
##------------------
# Example 1: Simulated binary responses
# Inspired by [http://dx.doi.org/10.1016/j.csda.2017.09.004]
##------------------
## Basic set up and true parameters
set.seed(052024)
num_clus <- 200
num_resp <- 6
response_type <- "binomial"
dat <- data.frame(id = rep(1:num_clus, sample(10:15, size = num_clus, replace = TRUE)))
p <- 15
H <- abs(outer(1:p, 1:p, "-"))
X <- rmvnorm(nrow(dat), sigma = 0.5^H)
colnames(X) <- paste0("x", 1:ncol(X))
dat <- cbind(dat, X)
rm(X)
str(dat)
true_fixed_effects <- cbind(
runif(num_resp, -1, 1),
rnorm(num_resp,0.5,sd=0.5),
rnorm(num_resp,-0.5,sd=0.5),
replicate(4, sample(c(-0.25,0,0.25),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 3 unique values, including zero
replicate(4, sample(c(-0.125,0),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 2 unique values, including zero
replicate(5, numeric(num_resp)))
true_fixed_effects

true_G <- rbind(c(1,0.8,0.4,-0.6,-0.3,-0.15),
c(0.8,1,0.6,-0.4,-0.2,-0.1),
c(0.4,0.6,1,-0.2,-0.1,-0.05),
c(-0.6,-0.4,-0.2,1,0.6,0.3),
c(-0.3,-0.2,-0.1,0.6,1,0.3),
c(-0.15,-0.1,-0.05,0.3,0.3,1))

true_ranef_cov <- rbind(c(2,1,0,0,0),
c(1,2,0,0,0),
c(0,0,1,0,0),
c(0,0,0,0.5,0),
c(0,0,0,0,0.25))/2

true_Sigma <- kronecker(true_G, true_ranef_cov)

rm(H, p)

## Simulate longitudinal/independent cluster multivariate responses
simy <- generatedata_mglmm(formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat,
fixed_effects = true_fixed_effects,
Sigma = true_Sigma,
response_type = response_type,
trial_size = 1)

str(simy)


## Fitting stacked univariate GLMMs -- **Real application starts here**

sglmms <- stackedGLMMs(y = simy$y[,-ncol(simy$y)],
response_type = response_type,
formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat,
trial_size = 1)

str(sglmms)

sglmms$resp1$point_estimates # Example of point estimates from response 1


##------------------
# Example 2: Simulated Poisson responses
# Inspired by [http://dx.doi.org/10.1016/j.csda.2017.09.004]
##------------------
## Basic set up and true parameters
set.seed(052024)
num_clus <- 200
num_resp <- 6
response_type <- "poisson"
dat <- data.frame(id = rep(1:num_clus, sample(10:15, size = num_clus, replace = TRUE)))
p <- 15
H <- abs(outer(1:p, 1:p, "-"))
X <- rmvnorm(nrow(dat), sigma = 0.5^H)
colnames(X) <- paste0("x", 1:ncol(X))
dat <- cbind(dat, X)
rm(X)
str(dat)
true_fixed_effects <- cbind(
runif(num_resp, -1, 1),
rnorm(num_resp,0.5,sd=0.5),
rnorm(num_resp,-0.5,sd=0.5),
replicate(4, sample(c(-0.25,0,0.25),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 3 unique values, including zero
replicate(4, sample(c(-0.125,0),size=num_resp,replace=TRUE)),
# 3 covariates where in each covariate there are at most 2 unique values, including zero
replicate(5, numeric(num_resp)))
true_fixed_effects

true_G <- rbind(c(1,0.8,0.4,-0.6,-0.3,-0.15),
c(0.8,1,0.6,-0.4,-0.2,-0.1),
c(0.4,0.6,1,-0.2,-0.1,-0.05),
c(-0.6,-0.4,-0.2,1,0.6,0.3),
c(-0.3,-0.2,-0.1,0.6,1,0.3),
c(-0.15,-0.1,-0.05,0.3,0.3,1))

true_ranef_cov <- rbind(c(2,1,0,0,0),
c(1,2,0,0,0),
c(0,0,1,0,0),
c(0,0,0,0.5,0),
c(0,0,0,0,0.25))/2

true_Sigma <- kronecker(true_G, true_ranef_cov)

rm(H, p)

## Simulate longitudinal/independent cluster multivariate responses
simy <- generatedata_mglmm(formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat,
fixed_effects = true_fixed_effects,
Sigma = true_Sigma,
response_type = response_type)

str(simy)


## Fitting stacked univariate GLMMs -- **Real application starts here**

sglmms <- stackedGLMMs(y = simy$y[,-ncol(simy$y)],
response_type = response_type,
formula_X = ~ . - id,
formula_Z = ~ x1 + x2 + x3 + x4,
data = dat)

str(sglmms)

sglmms$resp3$point_estimates # Example of point estimates from response 3
}


}
\seealso{
\code{\link[=coque]{coque()}} for the main function for constructing a COQUE fit, \code{\link[=estimates.coque]{estimates.coque()}} for extracting values from a COQUE fit, and \code{\link[=generatedata_mglmm]{generatedata_mglmm()}} for simulating data from a longitudinal/independent cluster multivariate generalized linear mixed model#'
}
\author{
Francis K.C. Hui \href{mailto:francis.hui@anu.edu.au}{francis.hui@anu.edu.au}
}
